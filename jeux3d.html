<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Mini FPS 3D - Prototype</title>
  <style>
    body { margin:0; overflow:hidden; background: #202020; color: #fff; font-family: monospace;}
    #score { position: fixed; top: 10px; left: 10px; font-size: 20px; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    const floorGeometry = new THREE.PlaneGeometry(100, 100);
    const floorMaterial = new THREE.MeshStandardMaterial({color: 0x228822});
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => {
      controls.lock();
    });

    camera.position.set(0, 2, 5);

    const move = { forward:false, backward:false, left:false, right:false };
    document.addEventListener('keydown', e => {
      switch(e.code) {
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
      }
    });
    document.addEventListener('keyup', e => {
      switch(e.code) {
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
      }
    });

    class Enemy {
      constructor(x, z) {
        this.mesh = new THREE.Mesh(
          new THREE.BoxGeometry(1, 2, 1),
          new THREE.MeshStandardMaterial({color: 0xff0000})
        );
        this.mesh.position.set(x, 1, z);
        scene.add(this.mesh);
        this.alive = true;
      }
      moveRandom() {
        if(!this.alive) return;
        this.mesh.position.x += (Math.random()-0.5)*0.05;
        this.mesh.position.z += (Math.random()-0.5)*0.05;
      }
      die() {
        this.alive = false;
        scene.remove(this.mesh);
      }
    }

    const enemies = [];
    for(let i=0; i<5; i++){
      enemies.push(new Enemy((Math.random()-0.5)*50, (Math.random()-0.5)*50));
    }

    const raycaster = new THREE.Raycaster();
    let score = 0;
    const scoreEl = document.getElementById('score');

    window.addEventListener('click', () => {
      if(!controls.isLocked) return;
      raycaster.setFromCamera({x: 0, y: 0}, camera);
      const intersects = raycaster.intersectObjects(enemies.filter(e=>e.alive).map(e=>e.mesh));
      if(intersects.length > 0){
        const enemyHit = enemies.find(e => e.mesh === intersects[0].object);
        enemyHit.die();
        score++;
        scoreEl.textContent = `Score: ${score}`;
      }
    });

    function animate() {
      requestAnimationFrame(animate);
      const speed = 0.1;
      if(controls.isLocked){
        const direction = new THREE.Vector3();
        if(move.forward) direction.z -= 1;
        if(move.backward) direction.z += 1;
        if(move.left) direction.x -= 1;
        if(move.right) direction.x += 1;
        direction.normalize();

        controls.moveRight(direction.x * speed);
        controls.moveForward(direction.z * speed);
      }

      enemies.forEach(e => e.moveRandom());

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>